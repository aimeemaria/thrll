{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}}
{\colortbl ;\red0\green0\blue0;\red255\green0\blue0;\red0\green0\blue255;\red0\green128\blue0;\red255\green255\blue255;}
{\*\generator Msftedit 5.41.15.1515;}\viewkind4\uc1\pard\cfpat5\shading10000\cf1\b\f0\fs24 Tentative Design: \b0\par
\~ \par
\cf2 // Can we use a double instead of a float everywhere since we need to add a float conversion since 0.0 is treated as double \par
// in Java (by default)\cf1  \par
\cf2 // Also, we need a function definition for CalculateRevenue - You have added RunThroughADay().. I got the basic idea.\cf1  \par
\cf2 // Maybe, you have forgotten to add the park attributes - Capacity, Admission etc...? Same with other classes like Land, \cf1\par
\pard\cfpat5\shading10000\sa280\cf2 // Restaurant etc..\cf1  \par
// Need to define the Duration parameter and make it a super class so that we can type convert it to days/weeks/months/years. So its an abstract class.\par
// use a hashtable to store the identifier and the entire object created\~\par
\cf3 // Maybe double would be better, because we can have evrything mapped as double in the backend.\cf1  \cf3 //also, there are functions finrevenue and generaterevenue, are they equivalent to    \par
//CalculateRevenue, just changed name I suppose\cf1  \par
\~ \par
\pard\cfpat5\shading10000 class Park \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ List<Land> LandList; \par
\~ \par
\cf2 // Does a Park always contain 6 lands?? I think we can have a maximum of 6 lands in the Park. So, we should\cf1  \par
\cf2 // update the LandList array whenever we create a land in the grammar instead of CreateLands()\cf1  \par
\cf2 // Ex: \cf1\par
\cf2 // Land l = new Land(); - create a land object\cf1  \par
\cf2 // p.addToLandList(l); - add this land to the landlist in the park object.\cf1  \par
\~ \par
\cf3 //We\~ defined the park as hub which could be divided into 6 parts, that was our original design,\cf1  \par
\cf3 //but I suppose it is not a limiting factor. But, will it not depend on the user how many he create.\cf1  \par
\~ \par
//contains 6 Land objects \par
CreateLands() \{ \par
\~ \par
              // max lands = 6. first land is the entrance.\par
\~\~\~\~\~\~\~\~\~\~\~\~\~ //we can do this because there are only some predefined number of lands. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ for(i=0;i<6;i++) \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ Land l = new Land(/*pass appropriate params*/); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~ \tab     Land.Location = location // pass this parameter\par
\cf4 //Why is Land Location random?  Why do we want to keep this option away from the user? Also, we need to ensure that we don't give two lands the same location, thus using a random function will create errors \cf1\par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ LandList.add(l); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\} \par
\pard\cfpat5\shading10000\sa280\~ \par
\cf3 // Will we not passing some parameterss into the function or calculate everything from here\cf1   \par
// this function is calculateRevenue, pass crowd and duration parameters\par
findRevenue() \{ \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ float revenue = 0; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ for each l in LandList \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ revenue += l.findRevenue(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ return revenue; \par
\} \par
\~ \par
\cf2 // properties of the park\cf1  \par
\pard\cfpat5\shading10000\sa280\cf2 // getter/setter functions for the park properties\cf1  \par
\cf3 // is it neccessary to define getter/setter\cf1  \par
\pard\cfpat5\shading10000\} \par
\~ \par
//keeps track of where each thing is and paths between them. \par
class Land \{ \par
\pard\cfpat5\shading10000\li720\~ \par
Location x; \par
\~ \par
//list of things inside the Land. \par
List<LandElements> LandElementList; \par
\~ \par
//constructor \par
Land(Location givenX) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ x = givenX; \par
\} \par
\~ \par
//Methods \par
\~ \par
//adding an attraction or restaurant or store to a Land. \par
AddLandElement(LandElement a) \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ a.Location.x = random(generateValue); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ a.Location.y = random(generateValue); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ LandElementList.addElement(a); \par
\} \par
\~ \par
float findRevenue() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ float revenue = 0; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ for each l in LandElementList \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ revenue += l.revenueGenerated(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ return revenue; \par
\} \par
\~ \par
\pard\cfpat5\shading10000\cf2 // properties of the land\cf1  \par
\cf2 // getter/setter functions for the land properties\cf1  \par
\pard\cfpat5\shading10000\sa280\cf3 // is it neccessary to define getter/setter\cf1  \par
\pard\cfpat5\shading10000\~ \par
\} \par
\~ \par
// can we make this an abstract class? If that is the idea, then I am cool with it. \par
// many advantages that I see to having a data structure such as this one. \par
class LandElements \{ \par
\~ \par
Location <x,y>; //where is this land element - randomly generate the centre and the boundary for the land\par
Int timeNeeded; //Min Number of ticks for which a customer must stay there. \par
Int revenueGenerated; //each landelement keeps track of how much it generated. we add later \par
\pard\cfpat5\shading10000\li720\~ \par
//Virtual methods, to be defined by inheriting classes. \par
//to be implemented by each of Restaurant, Store and Attribute. \par
Virtual int CanEnter(); //check if person can enter \par
Virtual Exit(); // on exit, change person\rquote s attributes \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ Virtual Enter(); \par
\} \par
\~ \par
class Restaurant extends LandElements\{ \par
\pard\cfpat5\shading10000\li720 Int Spend; \par
Int EnergyGain; \par
\pard\cfpat5\shading10000\sa280             Int Capacity; \par
\~ \par
\cf3 // Is there a difference between above and below int\cf1  \par
\pard\cfpat5\shading10000\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ int currentCapacity; \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Restaurant(/*pass the right params*/) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity = 0; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ timeNeeded = 600;\~\~\~\~\cf3 //Is this the mmaximum amount one can remain in the restuarant?\cf1  \par
\cf4 //What does the timeNeeded value represent?  The maximum or minumum amount of time needed?  I don't think we can define a maximum, as, theoretically, a guest can stay as long as they want in a restaurant.  However, for ease, we should probably just set one standard amount of time everyone spends in the restaurant.  \cf1\par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~ \par
\cf2 // properties of the restaurant\cf1  \par
\cf2 // getter/setter functions for the restaurant properties\cf1  \par
\cf3 // is it neccessary to define getter/setter\cf1  \par
\pard\cfpat5\shading10000\sa280\cf4 // I think so.  Unless we want to limit access to certain variables, it's always a good idea to have these functions, as it's easier to include them now then to go back and add them when/if we need them.\cf1\~ \par
Public: \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ int CanEnter(Person p) \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ if(p.Spend > Spend && Capacity > currentCapacity) \{ \par
\pard\cfpat5\shading10000\sa280\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity++;\~ \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ return true; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \}\~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ return false; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Exit() \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity--;\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Enter(Person p) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity++;\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ revenueGenerated += p.Spend; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\} \par
\~ \par
class Attraction extends LandElements\{ \par
\pard\cfpat5\shading10000\li720 Int Thrill; \par
Int Energy; \par
Int Capacity; \par
\~\cf3 // Is there a difference between above and below int\cf1  \par
int currentSize; \par
\pard\cfpat5\shading10000\~ \par
\cf2 // properties of the attraction\cf1  \par
\cf2 // getter/setter functions for the attraction properties\cf1  \par
\pard\cfpat5\shading10000\sa280\cf3 // is it neccessary to define getter/setter\cf1  \par
\pard\cfpat5\shading10000\li720\~ \par
//short used because it will never have the range of int \par
Attraction(short givenThrll, short givenEnergy, short givenCapacity) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ Thrill = givenThrll; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ Energy = givenEnergy; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ Capacity = givenCapacity; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ timeNeeded = 600; \par
\} \par
\pard\cfpat5\shading10000\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ int CanEnter(Person p) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ if(p.Thrill > Thrill && p.Energy > Energy && Capacity > currentSize) \{ \par
\pard\cfpat5\shading10000\sa280\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentSize++;\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~ return true; \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Enter(Person p) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentSize++;\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Exit(Person p) \{ \par
\pard\cfpat5\shading10000\sa280\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ //modify Thrll levels for the person? Dont remember what we decided. \par
\~\~\~\~\~\~\~\~\~\~\~\cf3 //Yes we need to modify them, didnt decide how much though, I think decrease by 0.5 or max 1\cf1  \par
\cf3\~\~\~\~\~\~\~\~\~\~\~// as we are having\~ the ranges pretty close in figures(1-10)\cf1  \par
\tab\cf4 //I thought thrill levels were constant, as it's a preference that shouldn't change.  It's the energy level that shoudl decrease.\cf1\par
\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~p.Energy -= Energy; //should we do it by a smaller factor instead? \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentSize--; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\} \par
\~ \par
class Store extends LandElements \{ \par
\~ \par
Int Spend; \par
\~ \par
Int currentCapacity; \par
\~ \par
Store(/*pass params*/) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Spend = passedParam; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity = 0; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ timeNeeded = 600; \par
\} \par
\~ \par
// properties of the store \par
// getter/setter functions for the store properties \par
\cf3 // is it neccessary to define getter/setter\cf1\~ \par
int CanEnter(Person p) \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ if(p.Spend > Spend && p.Capacity > currentCapacity) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity++; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ return true; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ return false; \par
\} \par
\~ \par
Enter() \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ generatedRevenu += Spend; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity++; \par
\} \par
\~ \par
Exit(Person p) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ p.Spend -= Spend; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ currentCapacity--; \par
\} \par
\} \par
\~ \par
\cf2 // suppose the user sets crowd size to 1000, then we will end up creating 1000 person objects. This can degrade the\cf1  \par
\cf2 // performance. But we decided that Person will be a very small object.\cf1  \par
\~ \par
class Crowd \{ \par
\pard\cfpat5\shading10000\li720 Int Thrill; \par
Int Energy; \par
Int SpendCapacity; \par
Int Size; \par
\~ \par
//Crowd here contains Size number of people. \par
Persons p[Size]; \par
\~ \par
Distribution d; \par
\~ \par
Crowd() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ d = Normal; //default \par
\} \par
\~ \par
//Methods: \par
\pard\cfpat5\shading10000\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ generatePersonObjects() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ short thrillArray = d.generateArray(Thrill); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ short energyArray = d.generateArray(Energy); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ short spendArray = d.generateArray(SpendCapacity); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ for(i=0;i<Size;i++) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ //p is the Persons field in Crowd. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ p[i] = new Person(thrillArray[i],energyArray[i], spendArray[i]); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \}\~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~ \par
\~\~\~\~ //The function CalculateRevenue has a backend counterpart (perhaps more than 1 counterpart) \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ RunThroughADay(Crowd c) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ for each time step in the day \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ for each Person p in Crowd c \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ decision = p.rollDie(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ switch(decision) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ case 1 : //change the land element the person is going to \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ List newLandElement = p.findClosestLandElement(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ p.changeDestination(newLandElement); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ break; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ case 2 : //continue with the same land element \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~ if(p.reached()) \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ p.Enter(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~ else p.walk(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~ break; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ case 3 : //other cases as we think of it... \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ p.walk(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\} \par
\~ \par
\~ \par
class Person \{ \par
Int Thrill; \par
\~\~\~\~\~\~\~\~\~\~\~\~Int Energy; \par
\pard\cfpat5\shading10000\li720 Int SpendCapacity; \par
\~ \par
LandElement currentDestination; \par
\~ \par
//a clock that keeps ticking through the day. \par
Int startTime; \par
Int timeAtcurrentDestination; \par
boolean inside; \par
Person() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ currentDestination = null; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ //to be modified. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Location.x = parkEntrancex; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Location.y = parkEntrancey; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ inside = false; \par
\} \par
\~ \par
Location<x,y> // (x,y) pair. which data structure is best here? \par
Direction radian;//to know which way a person was moving. \par
\~ \par
//Methods: \par
\~ \par
//simulate walking along a road in the park. \par
Walk() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ if(p.isInside()) \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ timeAtCurrentDestination++; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ //person has already finished needed time. Can go out now. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ if(timeAtCurrentDestination == currentDestination.timeNeeded) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ inside = false; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ timeAtCurrentDestination = false; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ currentDestination.Exit(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ else \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ take one step in the Direction (change Location.x and Location.y) \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\} \par
\~ \par
//Simulate decision making \par
short rollDie() \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ roll a six edged die and decide whether\~ or not a detour is to be taken. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ return decision; /*values 1 through 6*/ \par
\} \par
\~ \par
\pard\cfpat5\shading10000\~\~\~\~\~\~\~\~\~\~\~\~\~ LandElement findClosestLandElements() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ Land iAmIn = findContainingLand(Location.x, Location.y); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ LandElement chosen = null; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ for each LandElement l in iAmIn \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ distance = calculateDistance(l,p); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ if(mindistance < distance) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ mindistance = distance; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ chosen = l; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ return chosen; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\pard\cfpat5\shading10000\li720\~ \par
changeDestination(LandElement newDestination) \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ //this can be done in calling function. This is however more convenient. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ if(p.currentDestination == newDestination) \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ return; \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ currentDestination = newDestination; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Direction.radian = ---; \par
\} \par
\~ \par
Enter() \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ inside = true; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ currentDestination.Enter(this); \par
\} \par
\~ \par
//did person reach the destination? \par
reached() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ if(Location.x == currentDestination.Location.x && Location.y == currentDestination.Location.y) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ return true; \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ return false; \par
\} \par
\~ \par
isInside() \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ return inside; \par
\} \par
\pard\cfpat5\shading10000\} \par
\~ \par
\~ \par
//a class that decides what distribution is allowed for the crowd. \par
//Hemanth and I had tought seeing the effect of different distributions might be interesting. \par
// Again, better to make this an abstract class \par
\~ \par
class Distribution \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ int generatedArray[size]; //size of the Crowd for which this is getting generated. \par
\~ \par
\~\~\~\~ virtual int[] generateNumbers(/*mean value, size of crowd etc*/) \{ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \~\~\~\~\~\~\~\~\~\~\~\~\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\~ \par
\} \par
\~ \par
// check out http://www.itl.nist.gov/div898/handbook/eda/section3/eda366.htm \par
//this is easy to do because : \par
//once we figure out how to do this for normal, I am guessing that changing the \par
//equation is all that is required for changing the distribution. \par
\~ \par
class ChiSquareDistribution extends Distribution \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ //Algorithm to do this comes in this method. Once method has finished running, \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ //generateArray should have a set of numbers that satisfy the chi square distribution \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ //and has mean of whichever number we gave. \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ int[] generateNumbers(/* take mean value or whatever as input*/) \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \} \par
\} \par
\~ \par
//all other classes should look similar to ChiSquare. \par
class ExponentialDistribution extends Distribution \{ \par
\~ \par
\} \par
\line class TDistribution extends Distribution \{ \par
\~ \par
\} \par
\line class CauchyDistribution extends Distribution \{ \par
\~ \par
\} \par
\line\line class UniformDistribution extends Distribution \{ \par
\~ \par
\} \par
\~ \par
//tentative main function, to be code-generated. Which class should have it? Park? \par
// Maybe, we can create \par
\~ \par
public static void main() \{ \par
\~ \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Park p (/*pass args*/); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ Crowd d (/pass args */); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ \cf3 //Dont we need to define the days parameter here\cf1  \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ d.RunThroughADay(); \par
\~\~\~\~\~\~\~\~\~\~\~\~\~ p.findRevenue(); \par
\} \par
\~ \par
\par
}
 